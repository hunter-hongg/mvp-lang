# Miva Tutorial

## Prerequisites

- ‚úÖ Please read [Quick Start](./quick-start.md) first
- ‚úÖ Ensure the `miva` command is available (verify with `miva --version`)

---

## Viewing Project Files

After initializing the project, open the `src/main.miva` file. You will see the following content:

```miva
// main.miva
// Generated by Miva init
module "main"

main = () => {
  println("Hello, World")
}
```

### Code Breakdown

| Line | Code | Description |
|------|------|-------------|
| 1-2 | `// ...` | Line comments, **same usage as C language** |
| 3 | `module "main"` | Module declaration, indicates the current module name is `main` |
| 4 | *Empty line* | Recommended to keep an empty line after declarations for better readability |
| 5-7 | `main = () => {...}` | Main function definition |

### Key Concepts

> üîë **Main Module**: `main` is a **special module name**, indicating the current module is the entry module of the program.
>
> üîë **Main Function**: The `main` function is the **entry point of a Miva program**, where execution begins.
>
> üîë **Function Syntax**: The function definition format in Miva is:
> ```miva
> function_name = (parameters) => { function_body }
> ```
>
> üîë **Built-in Function**: `println` is a **built-in function** in Miva, requiring no import and cannot be overridden.
>
> üîë **Function Parameters**: Function parameters **must be enclosed in parentheses**, with multiple parameters separated by commas.
>
> üîë **Comments**: Miva comment style is the same as C, supporting **line comments** (`//`) and **block comments** (`/* */`).
>
> üîë **Statements**: Statements in Miva are **automatically delimited, no semicolons needed**; the parser **will report an error if it encounters a semicolon**.

---

## Defining Variables

### Basic Syntax

```miva
// Immutable variable (default)
variable_name := value

// Mutable variable (requires explicit declaration)
mut variable_name := value
```

### Core Rules

| Rule | Description | Example |
|------|-------------|---------|
| **Immutable by Default** | Variables cannot be reassigned after definition | `x := 5` |
| **Mutable Requires Declaration** | Use the `mut` keyword to declare mutable variables | `mut y := 5` |
| **Assignment Uses `=`** | Mutable variables use `=` for reassignment | `y = 10` |
| **Must Initialize** | Defining a variable without initialization is not allowed | ‚ùå `mut x;` |
| **Type Inference** | Manual type annotation is not currently supported | ‚ùå `x: int := 5` |

### Examples

```miva
// Immutable variable
pi := 3.14159
// pi = 3.14  // ‚ùå Error: cannot reassign

// Mutable variable
mut counter := 0
counter = 1      // ‚úÖ Correct
counter = 2      // ‚úÖ Correct
```

---

## Outputting Variables

### Print Functions

> ‚ö†Ô∏è **Note**: In Miva, **you cannot directly use `print` or `println` to output variables**. Please use the following functions:

| Function | Description | Example |
|----------|-------------|---------|
| `prints(...)` | Outputs arguments sequentially, **no newline** | `prints("x = ", x)` |
| `printlns(...)` | Outputs arguments sequentially, **newline at the end** | `printlns("x = ", x)` |

### Parameter Rules

- Parameters can be any **built-in type** (user-defined types will be supported in the future)
- Multiple parameters will be **concatenated and output sequentially**

### Examples

```miva
a := 5
b := 10

prints("a = ", a)           // Output: a = 5 (no newline)
printlns("b = ", b)         // Output: b = 10 (with newline)

printlns("a + b = ", a + b) // Output: a + b = 15
```

### Output Comparison

```miva
// Using prints
prints("Hello, ")
prints("World!")
// Output: Hello, World!

// Using printlns
printlns("Hello, ")
printlns("World!")
// Output:
// Hello, 
// World!
```

---

## Types

### Built-in Types

Miva provides the following built-in types:

| Type | Description |
|------|-------------|
| `int` | 64-bit **platform-independent** integer |
| `bool` | Boolean value, `true` or `false` |
| `float` | 64-bit **platform-independent** floating-point number |
| `char` | Single **character** |
| `string` | String, **automatically managed memory** |
| `[type]` | Array, **element type is `type`** |

### Type Conversion

Type conversion in Miva is achieved through the `as` keyword:

```miva
x := 5 as float    // Integer to float
y := 5.5 as int    // Float to integer (automatically truncated)
```

---

## Conditional Control

### `if` Syntax

Miva provides `if` and `else` keywords for **conditional control**:

```miva
if (condition) /* parentheses cannot be omitted */ {
  ...
} else { 
  ...
}
```

> ‚ö†Ô∏è **Note**: Miva does not currently support **multi-branch `else if`**. The `elif` keyword will be introduced in version v0.0.5.

### `choose` Syntax

Miva provides a **`choose` statement similar to `switch`** for multi-branch conditional control:

```miva 
choose (some_var) {
  when (value1) {
    ...
  }
  when (value2) {
    ...
  }
  ...
  otherwise { // default branch cannot be omitted
    ...
  }
}
```

> üîÆ **Future Plan**: Miva will add **exhaustiveness checking** to ensure all possible cases are handled.

---

## Move and Copy

### `move` Primitive

Miva provides the `move` primitive for **moving data ownership**:

```miva
y := move x 
```

- After moving, **the original variable is inaccessible**
- Variables `move`d inside `if` or `choose` blocks **cannot be used after the block ends**

### `clone` Primitive

Miva provides the `clone` primitive for **copying data**:

```miva
y := clone x 
```

- After copying, **the original variable remains accessible**

### Automatic Copying

Miva allows **automatic copying** using the `x := y` syntax for **Copy types**:

**Copy Type Determination Rules**:
- Primitive types (`int`, `bool`, `float`, `char`) are all Copy types
- For `struct`, if all fields are **Copy types**, then the struct is a Copy type

---

## Functions

### Defining Functions

The function definition syntax in Miva is as follows:

```miva
function_name = (parameters) => {
  ...
}
```

- ‚ùå Miva **does not support function overloading**
- ‚úÖ Functions automatically return the **last expression**, or use `return expr` for explicit return

### Function Parameters

Miva function parameters are divided into two types: `own` and `ref`

| Parameter Type | Description | Call Method |
|----------------|-------------|-------------|
| `own` | Requires ownership | Requires `move` or `clone` when calling |
| `ref` | Read-only view | Pass directly, read-only and cannot be modified |

**Parameter Declaration Syntax**:

```miva
ref x: T    // ref parameter
own y: T    // own parameter
z: T        // default is own parameter
```

Multiple parameters are separated by `,`.