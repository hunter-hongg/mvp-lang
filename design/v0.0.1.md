当然！以下是 MVP 语言 v0.0.1 完整特性草案 —— 综合你所有反馈，去符号化、显式安全、语法对称、无历史包袱。

📘 MVP Language – v0.0.1 完整特性草案  
目标：最小可行、内存安全、无 GC、无隐式行为、可编译为原生二进制

🔑 核心哲学
- 显式语义：所有权、借用、复制必须清晰表达  
- 零符号污染：不用 &, *, !, -> 等易混淆符号  
- 安全默认：编译期杜绝 use-after-free / double-free / data race  
- 表达式导向：函数即值，最后表达式自动返回  
- 对称设计：move 与 clone 作为一对核心操作  

1. 变量声明

语法
x := 42          // 不可变绑定（类型推导）
mut y := [1, 2]  // 可变绑定

规则
- 唯一声明操作符：:=  
- 默认不可变；需可变时加 mut，然后可以用 = 赋值
- 作用域结束自动析构（RAII）  

2. 所有权操作（关键字）
操作   语法   语义
转移   move x   放弃 x 的所有权，x 失效

深拷贝   clone x   创建 x 的语义正确副本，x 仍有效

示例
a := [1, 2, 3]
b := move a      // a 不可用
c := clone b     // b 仍可用，c 是独立副本

赋值规则
- Copy 类型（如 int, bool, 纯值 struct）→ 允许 y := x  
- non-Copy 类型（如 [T], string）→  
  - ❌ 禁止 y := x  
  - ✅ 必须 move x 或 clone x  

3. Copy 判定（全自动，不可覆盖）

一个类型是 Copy，当且仅当：
- 是内置简单类型：int, bool, float32, float64, char
- 是 struct，且所有字段递归为 Copy
- 不是：动态数组 [T]、字符串 string、含资源的结构体（如文件句柄）

💡 用户无法干预此判定；编译器在 AST 阶段静态分析

4. 函数定义（表达式风格）

语法
add = (a: int, b: int): int => a + b

greet = (ref name: string): void => {
    "Hello, name!"
}

规则
- 函数是一等值，可赋值、传递、返回  
- 单表达式函数：省略 {} 和 return  
- 多语句函数：最后表达式自动返回；提前退出用 return expr  
- 返回值类型：暂不支持自动推导，在参数后使用: type注明

5. 参数传递（显式语义）
语法   语义   调用方式
ref x: T   只读借用   f(arg)

x: T       所有权接管   f(move arg)

示例
// 借用：标 ref
hash = (ref data: [byte]) -> int { ... }

// 所有权：不标（默认）
save = (f: File) { ... }

main = (): int => {
    buf := [1, 2]
    file := open_file()

    h := hash(buf)        // ✅ 借用，buf 仍有效
    save(move file)       // ✅ 转移，file 失效
}

❌ 禁止未标注的 non-Copy 参数（如 (x: [int])）  
❌ 不支持可变借用（v0.1 无 mut ref）

6. 内置类型（v0.0.1）
类型   说明
int   64 位有符号整数（平台无关）

bool   true / false

float32   32 位 IEEE 754 浮点

float64   64 位 IEEE 754 浮点

char   Unicode 标量值（U+0000–U+D7FF, U+E000–U+10FFFF）

[T]   动态数组（堆分配，non-Copy）

string   UTF-8 编码字符串（non-Copy）

struct   用户自定义结构体

7. 控制流（v0.0.1 子集）

- if condition { ... } else { ... }
- return expr（用于提前退出）

所有控制结构均为表达式（未来扩展）

8. 字符串与插值

语法
msg := "Hello, name! You have count items."

规则
- var 插入变量的 toString() 表示  
- 转义： 表示字面 

9. 内存安全保证

- 无裸指针，无手动内存管理  
- 编译期跟踪变量状态：valid / moved  
- 禁止使用已 moved 变量（编译错误）  
- 借用期间禁止 move（编译错误）  
- non-Copy 类型禁止隐式复制  

10. 编译器行为

- 输入：.mvp 源文件  
- 输出：LLVM IR → 原生二进制（通过 clang/lld）  
- 依赖：仅链接系统 libc（无 runtime 库）  
- 错误信息：明确指出 moved 变量、missing move、非法复制等  

🚫 v0.0.1 明确排除

- 泛型  
- 宏 / 编译时元编程  
- 异常处理（panic-only）  
- 并发（actor/channel 留给 v0.2）  
- 包管理 / 模块系统  
- Trait / 接口 / 继承  
- 隐式类型转换  
- 可变借用（mut ref）  
- 运算符重载  

✅ v0.0.1 成功标准

能编译并运行以下程序：
Point = struct { x: int, y: int }

distance = (ref p1: Point, ref p2: Point): float64 => {
    dx := p1.x - p2.x
    dy := p1.y - p2.y
    (dx * dx + dy * dy) as float64
}

main = (): int => {
    origin := Point{x = 0, y = 0}
    pt := Point{x = 3, y = 4}
    d := distance(origin, pt)
    printf("Distance: %f\n", d)
    0
}

🧱 实现路线图（下一步）

1. Lexer：识别 :=, move, clone, ref, mut, IDENT, INT, STRING...
2. Parser：构建 AST（VarDecl, FuncDef, MoveExpr, CloneExpr, RefParam...）
3. 类型检查器：推导类型 + Copy 判定
4. 借用/移动检查器：跟踪变量生命周期状态
5. 代码生成：LLVM IR → native binary

❤️ MVP 的气质总结

**不用一个让人皱眉的符号，  
不藏一个隐式的行为，  
不多写一个冗余的字，  
不牺牲一分系统级能力。**

📜 MVP v0.0.1 规范追加项 #1：语句终结规则
追加至“语法风格”或“词法约定”章节
MVP 源码不使用分号作为语句终结符。
语句在换行处自动终结，前提是当前语法结构已完整。
编译器依据上下文判断是否延续下一行，规则与 Go 语言的自动分号插入（ASI）一致：
行末为操作符（如 +, =, =>, (, [, {, ,）→ 续行
下一行起始为独立语句（如 if, for, IDENT :=, }）→ 当前语句终结
分号在词法分析阶段视为非法 token，出现时报告 syntax error。
此设计确保语法简洁、无歧义，且与表达式导向风格天然契合。

